const crypto = require('crypto');

/**
 * Validate input types.
 * @param {string} val
 * @param {string} secret
 */
function validateInput(val, secret) {
  if (typeof val !== 'string') throw new TypeError("Value must be a string.");
  if (typeof secret !== 'string') throw new TypeError("Secret must be a string.");
}

/**
 * Sign the given `val` with `secret`.
 *
 * @param {string} val
 * @param {string} secret
 * @return {string} Signed value
 */
exports.sign = function (val, secret) {
  validateInput(val, secret);

  const hmac = crypto.createHmac('sha256', secret)
                     .update(val)
                     .digest('base64url');  // Use base64url to avoid encoding issues

  return `${val}.${hmac}`;
};

/**
 * Unsign and decode the given `val` with `secret`,
 * returning `false` if the signature is invalid.
 *
 * @param {string} val
 * @param {string} secret
 * @return {string|boolean} Decoded value or false if invalid
 */
exports.unsign = function (val, secret) {
  validateInput(val, secret);

  const idx = val.lastIndexOf('.');
  if (idx === -1) return false; // No signature found

  const str = val.slice(0, idx);
  const expectedMac = exports.sign(str, secret);
  
  // Use constant-time comparison for security
  return safeCompare(expectedMac, val) ? str : false;
};

/**
 * Secure string comparison to prevent timing attacks.
 * @param {string} a
 * @param {string} b
 * @return {boolean}
 */
function safeCompare(a, b) {
  const bufA = Buffer.from(a);
  const bufB = Buffer.from(b);

  return crypto.timingSafeEqual(bufA, bufB);
}
